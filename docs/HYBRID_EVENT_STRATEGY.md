# Estrategia H√≠brida de Eventos: Lobby ‚Üí Transition ‚Üí Game Room

## üìã Tabla de Contenidos
- [Filosof√≠a](#filosof√≠a)
- [Flujo Completo](#flujo-completo)
- [Fases del Juego](#fases-del-juego)
- [Eventos por Fase](#eventos-por-fase)
- [Implementaci√≥n en Engines](#implementaci√≥n-en-engines)
- [Frontend: Listeners por Fase](#frontend-listeners-por-fase)
- [Migraciones de Estado](#migraciones-de-estado)

---

## Filosof√≠a

La arquitectura usa una **estrategia h√≠brida** que combina:

1. **Eventos gen√©ricos del BaseGameEngine** ‚Üí Para flujo de lobby y transiciones
2. **Eventos de infraestructura (countdown, initialized)** ‚Üí Para fase de transici√≥n
3. **Eventos espec√≠ficos del juego** ‚Üí Para la l√≥gica del juego en s√≠

**¬øPor qu√© h√≠brida?**
- ‚úÖ Reutiliza eventos comunes entre todos los juegos
- ‚úÖ Permite validaciones de conexi√≥n ANTES de cargar el engine
- ‚úÖ Separa responsabilidades: transici√≥n vs juego
- ‚úÖ No duplica c√≥digo entre juegos

---

## Flujo Completo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          FASE 1: LOBBY                               ‚îÇ
‚îÇ  Estado Room: waiting                                                ‚îÇ
‚îÇ  Engine: NO cargado                                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. Jugadores se conectan via Presence Channel                      ‚îÇ
‚îÇ  2. Master configura opciones (equipos, rondas, etc.)               ‚îÇ
‚îÇ  3. Master hace click "Iniciar Partida"                             ‚îÇ
‚îÇ     ‚Üí Backend: GameMatch::start()                                   ‚îÇ
‚îÇ     ‚Üí Backend: Cambia estado a ACTIVE                               ‚îÇ
‚îÇ     ‚Üí Backend: Emite game.started (BaseGameEngine)                  ‚îÇ
‚îÇ  4. Frontend: LobbyManager escucha .game.started                    ‚îÇ
‚îÇ     ‚Üí Redirige a /rooms/{code}                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      FASE 2: TRANSITION                              ‚îÇ
‚îÇ  Estado Room: active                                                 ‚îÇ
‚îÇ  Engine: NO cargado (a√∫n no existe)                                 ‚îÇ
‚îÇ  Vista: resources/views/rooms/transition.blade.php                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. RoomController::show() detecta estado ACTIVE                    ‚îÇ
‚îÇ     ‚Üí Renderiza vista transition con lista de jugadores esperados   ‚îÇ
‚îÇ  2. Presence Channel detecta jugadores conect√°ndose                 ‚îÇ
‚îÇ     ‚Üí Muestra badges: "Conectado ‚úì" / "Esperando..."               ‚îÇ
‚îÇ  3. Cuando TODOS los jugadores esperados est√°n presentes:           ‚îÇ
‚îÇ     ‚Üí Frontend: POST /api/rooms/{code}/ready                        ‚îÇ
‚îÇ     ‚Üí Backend: Emite GameCountdownEvent (3 segundos)                ‚îÇ
‚îÇ  4. Frontend escucha .game.countdown                                ‚îÇ
‚îÇ     ‚Üí Muestra countdown visual: "3... 2... 1..."                    ‚îÇ
‚îÇ  5. Cuando countdown = 0:                                           ‚îÇ
‚îÇ     ‚Üí Frontend: POST /api/rooms/{code}/initialize-engine            ‚îÇ
‚îÇ     ‚Üí Backend: GameMatch::initializeEngine()                        ‚îÇ
‚îÇ     ‚Üí Backend: Carga el engine del juego                            ‚îÇ
‚îÇ     ‚Üí Backend: Llama engine->initialize() y engine->startGame()     ‚îÇ
‚îÇ     ‚Üí Backend: Cambia estado a PLAYING                              ‚îÇ
‚îÇ     ‚Üí Backend: Engine emite GameInitializedEvent                    ‚îÇ
‚îÇ  6. Frontend escucha .game.initialized                              ‚îÇ
‚îÇ     ‚Üí Redirige a /rooms/{code} (ahora con engine cargado)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       FASE 3: GAME ROOM                              ‚îÇ
‚îÇ  Estado Room: playing                                                ‚îÇ
‚îÇ  Engine: CARGADO y ejecut√°ndose                                     ‚îÇ
‚îÇ  Vista: {slug}::game (ej: trivia::game)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. RoomController::show() detecta estado PLAYING                   ‚îÇ
‚îÇ     ‚Üí Carga vista del juego espec√≠fico                              ‚îÇ
‚îÇ  2. Frontend: BaseGameClient escucha eventos gen√©ricos:             ‚îÇ
‚îÇ     - .turn.started                                                 ‚îÇ
‚îÇ     - .turn.played                                                  ‚îÇ
‚îÇ     - .turn.ended                                                   ‚îÇ
‚îÇ     - .round.started                                                ‚îÇ
‚îÇ     - .round.ended                                                  ‚îÇ
‚îÇ     - .game.finished                                                ‚îÇ
‚îÇ  3. Frontend: GameClient espec√≠fico escucha eventos del juego:      ‚îÇ
‚îÇ     - .trivia.question-shown                                        ‚îÇ
‚îÇ     - .trivia.answer-submitted                                      ‚îÇ
‚îÇ     - .trivia.answer-revealed                                       ‚îÇ
‚îÇ     - .trivia.scores-updated                                        ‚îÇ
‚îÇ  4. Juego contin√∫a emitiendo eventos seg√∫n acciones de jugadores    ‚îÇ
‚îÇ  5. Cuando juego termina:                                           ‚îÇ
‚îÇ     ‚Üí Backend: Emite game.finished                                  ‚îÇ
‚îÇ     ‚Üí Backend: Cambia estado a FINISHED                             ‚îÇ
‚îÇ     ‚Üí Frontend: Redirige a /rooms/{code}/results                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Fases del Juego

### Estado de la Room en Base de Datos

```php
// database/migrations/2025_10_20_181109_create_rooms_table.php
$table->enum('status', ['waiting', 'active', 'playing', 'finished'])
      ->default('waiting');
```

| Estado | Descripci√≥n | Engine cargado | Vista |
|--------|-------------|----------------|-------|
| `waiting` | Lobby - esperando jugadores | ‚ùå NO | `rooms.lobby` |
| `active` | Transici√≥n - verificando conexiones | ‚ùå NO | `rooms.transition` |
| `playing` | Juego en curso | ‚úÖ S√ç | `{slug}::game` |
| `finished` | Juego terminado | ‚úÖ S√ç (pero inactivo) | `rooms.results` |

---

## Eventos por Fase

### üìç **Fase 1: LOBBY** (Estado: `waiting`)

**Eventos emitidos:**
- `player.joined` - Cuando un jugador se une
- `player.left` - Cuando un jugador sale
- `players.all-connected` - Cuando se alcanza m√≠nimo de jugadores
- `teams.config-updated` - Configuraci√≥n de equipos cambi√≥
- `teams.balanced` - Equipos balanceados autom√°ticamente

**Evento de salida:**
```javascript
{
  event: 'game.started',  // ‚Üê BaseGameEngine (App\Events\Game\GameStartedEvent)
  game_slug: 'trivia',
  game_state: { phase: 'starting', ... },
  total_players: 3,
  players: [
    { id: 1, name: 'Player 1' },
    { id: 2, name: 'Player 2' },
    { id: 3, name: 'Player 3' }
  ],
  timing: null  // Sin countdown a√∫n
}
```

**Responsabilidad del evento:**
- Redirigir a TODOS los jugadores del lobby al room
- NO inicia el juego, solo la transici√≥n

---

### üìç **Fase 2: TRANSITION** (Estado: `active`)

**Eventos emitidos:**

#### 1. `game.countdown`
```javascript
// App\Events\Game\GameCountdownEvent
{
  event: 'game.countdown',
  room_code: 'ABC123',
  seconds: 3,
  message: 'El juego comenzar√° en 3 segundos...',
  timestamp: '2025-10-25T10:07:20Z'
}
```

**Cu√°ndo se emite:**
- Despu√©s de `POST /api/rooms/{code}/ready`
- Cuando todos los jugadores del evento `game.started` est√°n conectados en el Presence Channel

**Responsabilidad:**
- Mostrar countdown visual (3...2...1...)
- Preparar al usuario para el inicio del juego

---

#### 2. `game.initialized`
```javascript
// App\Events\Game\GameInitializedEvent
{
  event: 'game.initialized',
  room_code: 'ABC123',
  game: 'trivia',
  phase: 'playing',
  initial_state: {
    current_round: 1,
    scores: { 1: 0, 2: 0, 3: 0 },
    // ... estado inicial espec√≠fico del juego
  },
  timestamp: '2025-10-25T10:07:24Z'
}
```

**Cu√°ndo se emite:**
- Despu√©s de `POST /api/rooms/{code}/initialize-engine`
- Cuando countdown llega a 0
- Despu√©s de que `GameMatch::initializeEngine()` carga el engine

**Responsabilidad:**
- Confirmar que el engine est√° cargado
- Redirigir del transition al game room
- Proporcionar estado inicial del juego

---

### üìç **Fase 3: GAME ROOM** (Estado: `playing`)

**Eventos gen√©ricos** (todos los juegos):

```javascript
// Turnos
turn.started    ‚Üí Turno de un jugador comenz√≥
turn.played     ‚Üí Jugador realiz√≥ una acci√≥n
turn.ended      ‚Üí Turno termin√≥

// Rondas
round.started   ‚Üí Nueva ronda comenz√≥
round.ended     ‚Üí Ronda termin√≥ (con resultados)

// Juego
game.finished   ‚Üí Juego termin√≥ (con ganador)
```

**Eventos espec√≠ficos del juego** (ejemplo: Trivia):

```javascript
trivia.question-shown     ‚Üí Nueva pregunta mostrada
trivia.answer-submitted   ‚Üí Jugador envi√≥ respuesta
trivia.answer-revealed    ‚Üí Se revela respuesta correcta
trivia.scores-updated     ‚Üí Puntuaciones actualizadas
```

---

## Implementaci√≥n en Engines

### BaseGameEngine (Padre)

Todos los engines heredan de `App\Contracts\BaseGameEngine`.

**Responsabilidades del BaseGameEngine:**

1. **M√©todo `startGame()`** - Emite `game.started` con timing metadata
2. **M√©todo `emitGenericEvent()`** - Emitir eventos gen√©ricos
3. **M√©todo `emitGameEvent()`** - Emitir eventos espec√≠ficos del juego

**C√≥digo simplificado:**

```php
// app/Contracts/BaseGameEngine.php

abstract class BaseGameEngine implements GameEngineInterface
{
    /**
     * Iniciar el juego (fase "starting")
     */
    public function startGame(GameMatch $match): void
    {
        // 1. Resetear m√≥dulos
        $this->resetModules($match);

        // 2. Setear fase a "starting"
        $gameState = $match->game_state ?? [];
        $gameState['phase'] = 'starting';
        $match->game_state = $gameState;
        $match->save();

        // 3. Emitir evento game.started (sin timing)
        event(new \App\Events\Game\GameStartedEvent(
            match: $match,
            gameState: $gameState,
            timing: null  // ‚Üê Sin countdown, solo redirecci√≥n
        ));

        // 4. Espera a que todos los jugadores lleguen al room
        // 5. RoomController llama a initializeEngine() despu√©s
    }

    /**
     * Emitir evento gen√©rico (turn, round, game)
     */
    protected function emitGenericEvent(GameMatch $match, string $eventName, array $data): void
    {
        $eventClass = $this->getGenericEventClass($eventName);
        event(new $eventClass($match, $data));
    }

    /**
     * Emitir evento espec√≠fico del juego
     */
    protected function emitGameEvent(GameMatch $match, string $eventName, array $data): void
    {
        // Construir nombre del evento: "{slug}.{eventName}"
        $slug = $match->room->game->slug;
        $fullEventName = "{$slug}.{$eventName}";

        // Emitir evento custom
        broadcast(new GameEvent($match->room->code, $fullEventName, $data))->toOthers();
    }
}
```

---

### Engine Espec√≠fico (Hijo)

Ejemplo: `TriviaEngine`

```php
// games/trivia/TriviaEngine.php

namespace Games\Trivia;

use App\Contracts\BaseGameEngine;

class TriviaEngine extends BaseGameEngine
{
    /**
     * Hook espec√≠fico del juego para iniciar
     */
    protected function onGameStart(GameMatch $match): void
    {
        // Cargar preguntas
        $questions = $this->loadQuestions($match);

        // Guardar en estado
        $gameState = $match->game_state;
        $gameState['questions'] = $questions;
        $gameState['current_question_index'] = 0;
        $match->game_state = $gameState;
        $match->save();

        // Emitir primera pregunta
        $this->showNextQuestion($match);
    }

    /**
     * Mostrar siguiente pregunta
     */
    private function showNextQuestion(GameMatch $match): void
    {
        $state = $match->game_state;
        $questionIndex = $state['current_question_index'];
        $question = $state['questions'][$questionIndex];

        // Emitir evento espec√≠fico de Trivia
        $this->emitGameEvent($match, 'question-shown', [
            'question' => $question['question'],
            'options' => $question['options'],
            'question_number' => $questionIndex + 1,
            'total_questions' => count($state['questions']),
        ]);

        // Emitir evento gen√©rico de ronda
        $this->emitGenericEvent($match, 'round.started', [
            'round_number' => $questionIndex + 1,
        ]);
    }

    /**
     * Procesar respuesta de jugador
     */
    public function submitAnswer(GameMatch $match, Player $player, int $answerIndex): void
    {
        // Validar respuesta
        $state = $match->game_state;
        $question = $state['questions'][$state['current_question_index']];
        $isCorrect = ($answerIndex === $question['correct']);

        // Calcular puntos
        if ($isCorrect) {
            $points = $this->calculatePoints($player, $question);
            $this->scoreManager->addPoints($match, $player->id, $points);
        }

        // Emitir evento espec√≠fico
        $this->emitGameEvent($match, 'answer-submitted', [
            'player_id' => $player->id,
            'player_name' => $player->name,
            'answer_index' => $answerIndex,
            'is_correct' => $isCorrect,
        ]);

        // Emitir evento gen√©rico
        $this->emitGenericEvent($match, 'turn.played', [
            'player_id' => $player->id,
            'action' => ['type' => 'submit_answer', 'answer' => $answerIndex],
        ]);

        // Verificar si todos respondieron
        if ($this->allPlayersAnswered($match)) {
            $this->revealAnswer($match);
        }
    }
}
```

---

## Frontend: Listeners por Fase

### Fase 1: LOBBY

```javascript
// resources/js/core/LobbyManager.js

export class LobbyManager {
    initializeWebSocket() {
        const channel = window.Echo.channel(`room.${this.roomCode}`);

        // Evento de inicio de juego ‚Üí Redirigir al room
        channel.listen('.game.started', (data) => {
            console.log('üéÆ Game started, redirecting to transition...');
            window.location.replace(`/rooms/${this.roomCode}`);
        });
    }
}
```

---

### Fase 2: TRANSITION

```javascript
// resources/views/rooms/transition.blade.php

// 1. Presence Channel para detectar conexiones
const presenceChannel = window.Echo.join(`room.${roomCode}`);

presenceChannel.here((users) => {
    updatePlayerStatus(users);
    checkAllConnected();
});

// 2. Cuando todos conectados ‚Üí Llamar al backend
function checkAllConnected() {
    if (connectedUsers.length >= totalPlayers) {
        fetch(`/api/rooms/${roomCode}/ready`, { method: 'POST' });
    }
}

// 3. Escuchar countdown
const channel = window.Echo.channel(`room.${roomCode}`);

channel.listen('.game.countdown', (data) => {
    showCountdown(data.seconds); // 3... 2... 1...

    if (data.seconds === 0) {
        // Cuando llega a 0, inicializar engine
        fetch(`/api/rooms/${roomCode}/initialize-engine`, { method: 'POST' });
    }
});

// 4. Escuchar inicializaci√≥n ‚Üí Redirigir al juego
channel.listen('.game.initialized', (data) => {
    console.log('‚úÖ Game initialized, loading game view...');
    setTimeout(() => {
        window.location.replace(`/rooms/${roomCode}`);
    }, 1000);
});
```

---

### Fase 3: GAME ROOM

```javascript
// resources/js/games/trivia/TriviaClient.js

import { BaseGameClient } from '../../core/BaseGameClient.js';

export class TriviaClient extends BaseGameClient {
    constructor(roomCode) {
        super(roomCode); // ‚Üê Hereda listeners gen√©ricos
        this.setupTriviaListeners();
    }

    // Listeners de eventos GEN√âRICOS (heredados de BaseGameClient)
    // - .turn.started
    // - .turn.played
    // - .turn.ended
    // - .round.started
    // - .round.ended
    // - .game.finished

    // Listeners de eventos ESPEC√çFICOS de Trivia
    setupTriviaListeners() {
        const channel = window.Echo.channel(`room.${this.roomCode}`);

        channel.listen('.trivia.question-shown', (data) => {
            this.showQuestion(data.question, data.options);
        });

        channel.listen('.trivia.answer-submitted', (data) => {
            this.showPlayerAnswer(data.player_id, data.is_correct);
        });

        channel.listen('.trivia.answer-revealed', (data) => {
            this.revealCorrectAnswer(data.correct_index);
        });

        channel.listen('.trivia.scores-updated', (data) => {
            this.updateScoreboard(data.scores);
        });
    }

    showQuestion(question, options) {
        // Renderizar pregunta en UI
    }

    // ... m√©todos espec√≠ficos de Trivia
}
```

---

## Migraciones de Estado

### Room Status Migration

```php
// database/migrations/2025_10_25_100528_add_active_status_to_rooms_table.php

DB::statement("ALTER TABLE rooms MODIFY COLUMN status
    ENUM('waiting', 'active', 'playing', 'finished')
    NOT NULL DEFAULT 'waiting'");
```

### GameMatch State Transitions

```php
// app/Models/GameMatch.php

/**
 * Iniciar transici√≥n (Lobby ‚Üí Transition)
 * NO carga el engine
 */
public function start(): void
{
    $this->update(['started_at' => now()]);
    $this->room->update(['status' => Room::STATUS_ACTIVE]);

    // Emitir evento para redirigir jugadores
    event(new \App\Events\GameStartedEvent($this->room));
}

/**
 * Inicializar engine (Transition ‚Üí Game Room)
 * S√ç carga el engine
 */
public function initializeEngine(): void
{
    $game = $this->room->game;
    $engineClass = $game->getEngineClass();

    $engine = app($engineClass);
    $engine->initialize($this);
    $engine->startGame($this);

    $this->room->update(['status' => Room::STATUS_PLAYING]);
}
```

---

## Resumen: ¬øQu√© evento usar cu√°ndo?

| Fase | Estado Room | Evento | Prop√≥sito |
|------|-------------|--------|-----------|
| LOBBY ‚Üí TRANSITION | `waiting` ‚Üí `active` | `game.started` | Redirigir jugadores al room |
| TRANSITION (espera) | `active` | - | Verificar conexiones via Presence |
| TRANSITION (ready) | `active` | `game.countdown` | Mostrar countdown (3,2,1) |
| TRANSITION ‚Üí GAME | `active` ‚Üí `playing` | `game.initialized` | Engine cargado, ir al juego |
| GAME (jugando) | `playing` | `turn.*`, `round.*`, `{game}.*` | L√≥gica del juego |
| GAME ‚Üí RESULTS | `playing` ‚Üí `finished` | `game.finished` | Juego terminado |

---

## Beneficios de la Estrategia H√≠brida

‚úÖ **Validaci√≥n de conexiones ANTES del engine**
- No cargamos el engine si no est√°n todos conectados
- Ahorro de recursos

‚úÖ **Feedback visual al usuario**
- Lista de jugadores conect√°ndose
- Countdown antes de empezar
- Experiencia m√°s fluida

‚úÖ **Separaci√≥n de responsabilidades**
- `GameMatch::start()` ‚Üí Solo transici√≥n
- `GameMatch::initializeEngine()` ‚Üí Solo carga del engine
- Cada m√©todo tiene un prop√≥sito claro

‚úÖ **Reutilizaci√≥n de c√≥digo**
- Eventos gen√©ricos compartidos entre juegos
- Solo eventos espec√≠ficos var√≠an por juego

‚úÖ **Debuggeable y testeable**
- Cada evento es rastreable en logs
- Estados de Room claros y verificables

---

## Para Desarrolladores Futuros

**Cuando crees un nuevo juego:**

1. **Hereda de BaseGameEngine**
   ```php
   class MyGameEngine extends BaseGameEngine { ... }
   ```

2. **Implementa el hook `onGameStart()`**
   ```php
   protected function onGameStart(GameMatch $match): void {
       // Tu l√≥gica de inicio
   }
   ```

3. **Usa `emitGenericEvent()` para eventos comunes**
   ```php
   $this->emitGenericEvent($match, 'turn.started', [...]);
   $this->emitGenericEvent($match, 'round.ended', [...]);
   ```

4. **Usa `emitGameEvent()` para eventos espec√≠ficos**
   ```php
   $this->emitGameEvent($match, 'card-played', [...]);
   $this->emitGameEvent($match, 'dice-rolled', [...]);
   ```

5. **Crea tu cliente JS heredando de BaseGameClient**
   ```javascript
   class MyGameClient extends BaseGameClient {
       setupMyGameListeners() { ... }
   }
   ```

**NO necesitas:**
- ‚ùå Crear eventos de transici√≥n (ya existen)
- ‚ùå Manejar Presence Channel manualmente
- ‚ùå Implementar countdown (ya existe)
- ‚ùå Cambiar estados de Room manualmente

**Los eventos gen√©ricos y la transici√≥n son autom√°ticos** ‚úÖ
