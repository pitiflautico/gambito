# Dise√±o BaseGameEngine + BaseGameClient

**Fecha:** 26 Octubre 2025
**Objetivo:** Sistema modular reutilizable para todos los juegos
**Principio:** 0 queries durante el juego, WebSocket bidireccional, Redis state

---

## üéØ Objetivos

1. **BaseGameEngine** debe tener TODA la l√≥gica com√∫n del backend
2. **BaseGameClient** debe tener TODA la l√≥gica com√∫n del frontend
3. **Los juegos** solo implementan su l√≥gica espec√≠fica
4. **0 queries a MySQL** durante el juego (solo Redis + WebSocket)
5. **WebSocket bidireccional** - Cliente env√≠a acciones via WebSocket, no HTTP POST

---

## üì¶ Arquitectura del Sistema

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          FRONTEND (Cliente)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                          ‚îÇ
‚îÇ  BaseGameClient (resources/js/core/BaseGameClient.js)                  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ WebSocket Manager (enviar/recibir)                                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Event Listeners (round.started, round.ended, etc.)                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ State Synchronizer (sincronizar con servidor)                     ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Action Sender (enviar acciones via WebSocket)                     ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Reconnection Handler (handle disconnect/reconnect)                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ UI Helpers (scores, players, messages)                            ‚îÇ
‚îÇ                                                                          ‚îÇ
‚îÇ  TriviaGameClient extends BaseGameClient                               ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ displayQuestion()                                                  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ sendAnswer()  ‚Üê Usa BaseGameClient.sendGameAction()              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ handleAnswer\Result()                                               ‚îÇ
‚îÇ                                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚ñ≤  ‚ñº
                            WebSocket (Laravel Reverb)
                                    ‚ñ≤  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          BACKEND (Servidor)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                          ‚îÇ
‚îÇ  BaseGameEngine (app/Contracts/BaseGameEngine.php)                     ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ WebSocket Action Handler (procesar acciones del cliente)          ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Redis State Manager (cargar/guardar state)                        ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Event Broadcaster (broadcast a room via WebSocket)                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Reconnection Handler (graceful disconnect/reconnect)              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Module System (Round, Timer, Score, PlayerState)                  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Validation (authoritative server, no confiar en cliente)          ‚îÇ
‚îÇ                                                                          ‚îÇ
‚îÇ  TriviaEngine extends BaseGameEngine                                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ processRoundAction($action = 'answer')                            ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ validateAnswer()                                               ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ calculatePoints()                                              ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ updateState()                                                  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ startNewRound()                                                    ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ loadNextQuestion()                                             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ endCurrentRound()                                                  ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ getAllPlayerResults()                                          ‚îÇ
‚îÇ                                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚ñ≤  ‚ñº
                                Redis (State)
                                MySQL (Persistencia)
```

---

## üîß BaseGameEngine - Mejoras Necesarias

### Situaci√≥n Actual

```php
// ‚úÖ YA TIENE:
- Sistema de m√≥dulos completo
- Helpers para RoundManager, ScoreManager, PlayerStateManager
- Strategy Pattern para fin de ronda
- Events (RoundStarted, RoundEnded, GameFinished)
- Hook de disconnect/reconnect (vac√≠os)

// ‚ùå LE FALTA:
- WebSocket Action Handler (client ‚Üí server)
- Redis State Manager (todo usa MySQL game_state)
- Graceful disconnect/reconnect logic
- Broadcast helpers optimizados
- Player data cache en game_state
```

### Nuevos M√©todos a Agregar

```php
abstract class BaseGameEngine
{
    // ========================================================================
    // WEBSOCKET ACTION HANDLING (client ‚Üí server)
    // ========================================================================

    /**
     * Procesar acci√≥n recibida via WebSocket.
     *
     * Este m√©todo:
     * 1. Valida que el jugador existe (desde game_state, NO query)
     * 2. Valida que la acci√≥n es v√°lida en la fase actual
     * 3. Aplica rate limiting
     * 4. Delega al processAction() existente
     * 5. Broadcast resultado a todos
     *
     * @param GameMatch $match
     * @param int $playerId ID del jugador (desde WebSocket auth)
     * @param string $action Tipo de acci√≥n ('answer', 'draw', 'vote', etc.)
     * @param array $data Datos de la acci√≥n
     * @return array Resultado
     */
    public function handleWebSocketAction(
        GameMatch $match,
        int $playerId,
        string $action,
        array $data
    ): array {
        Log::info("[{$this->getGameSlug()}] WebSocket action received", [
            'match_id' => $match->id,
            'player_id' => $playerId,
            'action' => $action
        ]);

        // 1. Obtener Player desde game_state (NO query!)
        $player = $this->getPlayerFromState($match, $playerId);

        if (!$player) {
            return [
                'success' => false,
                'error' => 'Player not found',
            ];
        }

        // 2. Validar fase del juego
        if (!$this->canPlayerActInPhase($match, $action)) {
            return [
                'success' => false,
                'error' => 'Invalid action in current phase',
            ];
        }

        // 3. Rate limiting (evitar spam)
        if (!$this->checkRateLimit($playerId, $action)) {
            return [
                'success' => false,
                'error' => 'Rate limit exceeded',
            ];
        }

        // 4. Procesar acci√≥n (usa el m√©todo existente)
        try {
            $result = $this->processAction($match, $player, $action, $data);

            // 5. Broadcast resultado a todos (optimizado)
            $this->broadcastActionResult($match, $playerId, $action, $result);

            return array_merge(['success' => true], $result);

        } catch (\Exception $e) {
            Log::error("[{$this->getGameSlug()}] Error processing action", [
                'match_id' => $match->id,
                'player_id' => $playerId,
                'action' => $action,
                'error' => $e->getMessage()
            ]);

            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }

    /**
     * Obtener datos del jugador desde game_state (SIN query).
     *
     * Los datos del jugador se guardan en _config al inicializar el juego.
     *
     * @param GameMatch $match
     * @param int $playerId
     * @return Player|null
     */
    protected function getPlayerFromState(GameMatch $match, int $playerId): ?Player
    {
        $playerData = $match->game_state['_config']['players'][$playerId] ?? null;

        if (!$playerData) {
            return null;
        }

        // Crear Player object desde datos en memoria (NO query!)
        $player = new Player();
        $player->id = $playerData['id'];
        $player->name = $playerData['name'];
        $player->user_id = $playerData['user_id'];
        $player->avatar = $playerData['avatar'] ?? null;

        // NO hacer fillable, solo leer
        $player->exists = true;

        return $player;
    }

    /**
     * Validar si el jugador puede actuar en la fase actual.
     *
     * @param GameMatch $match
     * @param string $action
     * @return bool
     */
    protected function canPlayerActInPhase(GameMatch $match, string $action): bool
    {
        $phase = $match->game_state['phase'] ?? 'unknown';

        // Por defecto, solo permitir acciones durante 'playing'
        // Los juegos pueden sobrescribir para l√≥gica custom
        return $phase === 'playing';
    }

    /**
     * Rate limiting para prevenir spam.
     *
     * @param int $playerId
     * @param string $action
     * @return bool
     */
    protected function checkRateLimit(int $playerId, string $action): bool
    {
        $key = "game:action:{$playerId}:{$action}";

        // Max 10 acciones por minuto por defecto
        return RateLimiter::attempt(
            $key,
            $perMinute = 60,
            function() {
                // Allow
            }
        );
    }

    /**
     * Broadcast resultado de acci√≥n a todos los jugadores.
     *
     * Usa delta updates en lugar de enviar todo el state.
     *
     * @param GameMatch $match
     * @param int $playerId
     * @param string $action
     * @param array $result
     * @return void
     */
    protected function broadcastActionResult(
        GameMatch $match,
        int $playerId,
        string $action,
        array $result
    ): void {
        // Solo enviar lo que cambi√≥
        $deltaData = [
            'player_id' => $playerId,
            'action' => $action,
            'success' => $result['success'] ?? false,
            'timestamp' => now()->toDateTimeString(),
        ];

        // Agregar solo datos relevantes (NO todo el game_state)
        if (isset($result['points'])) {
            $deltaData['points'] = $result['points'];
        }

        if (isset($result['correct'])) {
            $deltaData['correct'] = $result['correct'];
        }

        broadcast(new \App\Events\Game\PlayerActionEvent(
            match: $match,
            data: $deltaData
        ))->toOthers();
    }

    // ========================================================================
    // REDIS STATE MANAGEMENT
    // ========================================================================

    /**
     * Cargar game_state desde Redis.
     *
     * @param int $matchId
     * @return array|null
     */
    protected function loadStateFromRedis(int $matchId): ?array
    {
        $state = Redis::get("game:match:{$matchId}:state");

        if (!$state) {
            return null;
        }

        return json_decode($state, true);
    }

    /**
     * Guardar game_state a Redis.
     *
     * @param int $matchId
     * @param array $state
     * @param int $ttl Tiempo de vida en segundos (default: 1 hora)
     * @return void
     */
    protected function saveStateToRedis(int $matchId, array $state, int $ttl = 3600): void
    {
        Redis::setex(
            "game:match:{$matchId}:state",
            $ttl,
            json_encode($state)
        );
    }

    /**
     * Sincronizar state: Redis ‚Üí MySQL.
     *
     * Llamar peri√≥dicamente (cada N rondas) como checkpoint.
     *
     * @param GameMatch $match
     * @return void
     */
    protected function syncStateToMySQL(GameMatch $match): void
    {
        $redisState = $this->loadStateFromRedis($match->id);

        if ($redisState) {
            $match->game_state = $redisState;
            $match->save();

            Log::info("[{$this->getGameSlug()}] State synced to MySQL", [
                'match_id' => $match->id
            ]);
        }
    }

    /**
     * Inicializar cache de jugadores en game_state.
     *
     * Esto se llama UNA VEZ en initialize() para guardar los datos de todos
     * los jugadores en _config y evitar queries durante el juego.
     *
     * @param GameMatch $match
     * @return void
     */
    protected function cachePlayersInState(GameMatch $match): void
    {
        $players = $match->players; // ‚Üê Query SOLO aqu√≠ (1 vez)

        $playersData = [];

        foreach ($players as $player) {
            $playersData[$player->id] = [
                'id' => $player->id,
                'name' => $player->name,
                'user_id' => $player->user_id,
                'avatar' => $player->avatar,
            ];
        }

        $gameState = $match->game_state;
        $gameState['_config']['players'] = $playersData;
        $match->game_state = $gameState;
        $match->save();

        // Tambi√©n guardar en Redis
        $this->saveStateToRedis($match->id, $gameState);

        Log::info("[{$this->getGameSlug()}] Players cached in state", [
            'match_id' => $match->id,
            'player_count' => count($playersData)
        ]);
    }

    // ========================================================================
    // GRACEFUL DISCONNECT/RECONNECT
    // ========================================================================

    /**
     * Manejar desconexi√≥n de jugador.
     *
     * Implementaci√≥n mejorada con grace period.
     *
     * @param GameMatch $match
     * @param Player $player
     * @return void
     */
    public function handlePlayerDisconnect(GameMatch $match, Player $player): void
    {
        Log::info("[{$this->getGameSlug()}] Player disconnected", [
            'match_id' => $match->id,
            'player_id' => $player->id
        ]);

        // Marcar como disconnected (NO eliminar)
        $playerState = $this->getPlayerStateManager($match);
        $playerState->setPlayerState($player->id, [
            'status' => 'disconnected',
            'disconnected_at' => now()->toDateTimeString(),
        ]);
        $this->savePlayerStateManager($match, $playerState);

        // Broadcast a otros jugadores
        broadcast(new \App\Events\Game\PlayerDisconnectedEvent(
            match: $match,
            playerId: $player->id
        ))->toOthers();

        // Programar removal si no reconecta en 30 segundos
        dispatch(new \App\Jobs\RemoveInactivePlayer($match, $player))
            ->delay(now()->addSeconds(30));
    }

    /**
     * Manejar reconexi√≥n de jugador.
     *
     * Implementaci√≥n mejorada con resync de state.
     *
     * @param GameMatch $match
     * @param Player $player
     * @return void
     */
    public function handlePlayerReconnect(GameMatch $match, Player $player): void
    {
        Log::info("[{$this->getGameSlug()}] Player reconnected", [
            'match_id' => $match->id,
            'player_id' => $player->id
        ]);

        // Marcar como active
        $playerState = $this->getPlayerStateManager($match);
        $playerState->setPlayerState($player->id, [
            'status' => 'active',
            'reconnected_at' => now()->toDateTimeString(),
        ]);
        $this->savePlayerStateManager($match, $playerState);

        // Broadcast a otros jugadores
        broadcast(new \App\Events\Game\PlayerReconnectedEvent(
            match: $match,
            playerId: $player->id
        ))->toOthers();

        // Enviar state actual al jugador reconectado (solo a √©l)
        broadcast(new \App\Events\Game\StateSyncEvent(
            match: $match,
            gameState: $this->getGameStateForPlayer($match, $player)
        ))->toOthers(); // Laravel filtra por socket_id
    }
}
```

---

## üé® BaseGameClient - Mejoras Necesarias

### Situaci√≥n Actual

```javascript
// ‚úÖ YA TIENE:
- Event listeners gen√©ricos
- TimingModule
- Helpers (getPlayer, getScore, etc.)
- sendAction() con HTTP POST

// ‚ùå LE FALTA:
- WebSocket action sender
- Reconnection handler
- State synchronizer
- Action queue (offline actions)
- Optimistic updates
```

### Nuevos M√©todos a Agregar

```javascript
export class BaseGameClient {
    constructor(config) {
        // ... existing code ...

        // Nuevo: Queue para acciones offline
        this.actionQueue = [];

        // Nuevo: Estado de conexi√≥n
        this.isConnected = true;
        this.isReconnecting = false;

        // Setup reconnection listeners
        this.setupReconnectionHandlers();
    }

    // ========================================================================
    // WEBSOCKET ACTION SENDING (client ‚Üí server)
    // ========================================================================

    /**
     * Enviar acci√≥n de juego via WebSocket.
     *
     * REEMPLAZA a sendAction() que usa HTTP POST.
     *
     * @param {string} action - Tipo de acci√≥n ('answer', 'draw', 'vote', etc.)
     * @param {object} data - Datos de la acci√≥n
     * @param {boolean} optimistic - Si aplicar optimistic update
     * @returns {Promise<object>} Resultado
     */
    async sendGameAction(action, data, optimistic = false) {
        console.log(`üì§ [BaseGameClient] Sending action via WebSocket:`, action, data);

        // Si no est√° conectado, encolar
        if (!this.isConnected) {
            console.warn('‚ö†Ô∏è  [BaseGameClient] Not connected, queueing action');
            this.actionQueue.push({ action, data, optimistic });
            return { success: false, queued: true };
        }

        // Optimistic update (opcional)
        if (optimistic) {
            this.applyOptimisticUpdate(action, data);
        }

        // Enviar via WebSocket usando whisper
        const channel = window.Echo.private(`room.${this.roomCode}`);

        channel.whisper('game.action', {
            action: action,
            data: data,
            player_id: this.playerId,
            timestamp: Date.now(),
        });

        // Esperar confirmaci√≥n del servidor via evento
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Action timeout'));
            }, 5000);

            // Listener para la confirmaci√≥n
            const confirmHandler = (event) => {
                if (event.player_id === this.playerId && event.action === action) {
                    clearTimeout(timeout);
                    channel.stopListening('.game.action.result', confirmHandler);
                    resolve(event);
                }
            };

            channel.listen('.game.action.result', confirmHandler);
        });
    }

    /**
     * Aplicar optimistic update (cambio visual inmediato).
     *
     * Los juegos espec√≠ficos sobrescriben esto.
     *
     * @param {string} action
     * @param {object} data
     */
    applyOptimisticUpdate(action, data) {
        // Los juegos espec√≠ficos implementan esto
        // Ejemplo en Trivia: deshabilitar botones, marcar selecci√≥n
    }

    /**
     * Revertir optimistic update si fall√≥.
     *
     * @param {string} action
     * @param {object} data
     */
    revertOptimisticUpdate(action, data) {
        // Los juegos espec√≠ficos implementan esto
        // Ejemplo en Trivia: re-habilitar botones
    }

    // ========================================================================
    // RECONNECTION HANDLING
    // ========================================================================

    /**
     * Setup de handlers de reconexi√≥n.
     */
    setupReconnectionHandlers() {
        if (!window.Echo?.connector?.socket) {
            console.warn('‚ö†Ô∏è  Echo not available for reconnection handling');
            return;
        }

        const socket = window.Echo.connector.socket;

        // Disconnect
        socket.on('disconnect', () => {
            console.warn('‚ö†Ô∏è  [BaseGameClient] WebSocket disconnected');
            this.isConnected = false;
            this.onDisconnect();
        });

        // Reconnecting
        socket.on('reconnecting', (attemptNumber) => {
            console.log(`üîÑ [BaseGameClient] Reconnecting (attempt ${attemptNumber})...`);
            this.isReconnecting = true;
            this.onReconnecting(attemptNumber);
        });

        // Reconnect
        socket.on('reconnect', () => {
            console.log('‚úÖ [BaseGameClient] WebSocket reconnected');
            this.isConnected = true;
            this.isReconnecting = false;
            this.onReconnect();
        });

        // Reconnect failed
        socket.on('reconnect_failed', () => {
            console.error('‚ùå [BaseGameClient] Reconnection failed');
            this.onReconnectFailed();
        });
    }

    /**
     * Callback: Desconectado.
     *
     * Los juegos espec√≠ficos pueden sobrescribir esto.
     */
    onDisconnect() {
        this.showMessage('Conexi√≥n perdida. Reconectando...', 'warning');
    }

    /**
     * Callback: Reconectando.
     *
     * @param {number} attemptNumber
     */
    onReconnecting(attemptNumber) {
        this.showMessage(`Reconectando (intento ${attemptNumber})...`, 'info');
    }

    /**
     * Callback: Reconectado.
     *
     * Sincroniza estado con el servidor y procesa acciones en cola.
     */
    async onReconnect() {
        this.showMessage('Reconectado. Sincronizando...', 'success');

        // 1. Solicitar estado actual del servidor
        await this.syncState();

        // 2. Procesar acciones en cola
        await this.processActionQueue();

        this.showMessage('Sincronizaci√≥n completa', 'success');
    }

    /**
     * Callback: Reconexi√≥n fallida.
     */
    onReconnectFailed() {
        this.showMessage('No se pudo reconectar. Recarga la p√°gina.', 'error');
    }

    /**
     * Sincronizar estado con el servidor.
     */
    async syncState() {
        console.log('üîÑ [BaseGameClient] Syncing state from server...');

        try {
            const response = await fetch(`/api/rooms/${this.roomCode}/state`);
            const data = await response.json();

            // Actualizar estado local
            this.gameState = data.game_state;
            this.scores = data.game_state.scoring_system?.scores || {};
            this.currentRound = data.game_state.round_system?.current_round || 1;

            // Los juegos espec√≠ficos sobrescriben onStateSync() para actualizar UI
            this.onStateSync(data.game_state);

            console.log('‚úÖ [BaseGameClient] State synced');
        } catch (error) {
            console.error('‚ùå [BaseGameClient] Error syncing state:', error);
        }
    }

    /**
     * Callback: Estado sincronizado.
     *
     * Los juegos espec√≠ficos sobrescriben esto para actualizar UI.
     *
     * @param {object} gameState
     */
    onStateSync(gameState) {
        // Los juegos espec√≠ficos implementan esto
        // Ejemplo en Trivia: displayQuestion(gameState.current_question)
    }

    /**
     * Procesar acciones en cola (despu√©s de reconectar).
     */
    async processActionQueue() {
        if (this.actionQueue.length === 0) {
            return;
        }

        console.log(`üì§ [BaseGameClient] Processing ${this.actionQueue.length} queued actions...`);

        for (const queuedAction of this.actionQueue) {
            try {
                await this.sendGameAction(
                    queuedAction.action,
                    queuedAction.data,
                    queuedAction.optimistic
                );
            } catch (error) {
                console.error('‚ùå [BaseGameClient] Error processing queued action:', error);
            }
        }

        this.actionQueue = [];
        console.log('‚úÖ [BaseGameClient] Action queue processed');
    }

    // ========================================================================
    // STATE SYNCHRONIZATION
    // ========================================================================

    /**
     * Aplicar delta update al estado local.
     *
     * En lugar de recibir todo el state, solo aplicar cambios incrementales.
     *
     * @param {object} delta - Cambios a aplicar
     */
    applyStateDelta(delta) {
        console.log('üîÑ [BaseGameClient] Applying state delta:', delta);

        // Actualizar scores si vienen en el delta
        if (delta.scores) {
            Object.assign(this.scores, delta.scores);
        }

        // Actualizar round si viene en el delta
        if (delta.current_round !== undefined) {
            this.currentRound = delta.current_round;
        }

        // Los juegos espec√≠ficos sobrescriben onDeltaApplied()
        this.onDeltaApplied(delta);
    }

    /**
     * Callback: Delta aplicado.
     *
     * @param {object} delta
     */
    onDeltaApplied(delta) {
        // Los juegos espec√≠ficos implementan esto
    }
}
```

---

## üîÑ Flujo Completo con WebSocket Bidireccional

### Ejemplo: Responder pregunta en Trivia

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. CLIENTE: Jugador hace clic en opci√≥n 2                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
        trivia.sendGameAction('answer', { answer_index: 2 }, true)
                                    ‚îÇ
                                    ‚îú‚îÄ Optimistic: Deshabilitar botones
                                    ‚îú‚îÄ WebSocket whisper: game.action
                                    ‚îÇ
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. SERVIDOR: Reverb recibe whisper                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
        WebSocketActionListener::handle($event)
                                    ‚îÇ
                                    ‚îú‚îÄ Cargar match desde Redis (1-2ms)
                                    ‚îú‚îÄ Llamar engine->handleWebSocketAction()
                                    ‚îÇ
                                    ‚ñº
        TriviaEngine::processRoundAction()
                                    ‚îÇ
                                    ‚îú‚îÄ Validar answer (desde game_state, 0 queries)
                                    ‚îú‚îÄ Calcular puntos
                                    ‚îú‚îÄ Actualizar Redis
                                    ‚îÇ
                                    ‚ñº
        Broadcast: PlayerActionEvent
                                    ‚îÇ
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. TODOS LOS CLIENTES: Reciben PlayerActionEvent                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
        trivia.handlePlayerAction(event)
                                    ‚îÇ
                                    ‚îú‚îÄ Si soy yo: Marcar respuesta como correcta/incorrecta
                                    ‚îú‚îÄ Si es otro: Mostrar "Juan respondi√≥"
                                    ‚îÇ
                                    ‚ñº
                              UI actualizada

```

**Latencia total:** ~10-20ms (vs ~100-200ms con HTTP POST)

**Queries a MySQL:** 0 (vs 3 con HTTP POST)

---

## üìù Checklist de Implementaci√≥n

### Backend (BaseGameEngine)

- [ ] Agregar `handleWebSocketAction()`
- [ ] Agregar `getPlayerFromState()` (sin query)
- [ ] Agregar `canPlayerActInPhase()`
- [ ] Agregar `checkRateLimit()`
- [ ] Agregar `broadcastActionResult()` (delta updates)
- [ ] Agregar `loadStateFromRedis()`
- [ ] Agregar `saveStateToRedis()`
- [ ] Agregar `syncStateToMySQL()` (checkpoints)
- [ ] Agregar `cachePlayersInState()` (llamar en initialize())
- [ ] Mejorar `handlePlayerDisconnect()` (grace period)
- [ ] Mejorar `handlePlayerReconnect()` (resync state)
- [ ] Crear `WebSocketActionListener` (escuchar whispers)
- [ ] Crear eventos: `PlayerActionEvent`, `PlayerDisconnectedEvent`, `PlayerReconnectedEvent`, `StateSyncEvent`
- [ ] Crear job: `RemoveInactivePlayer`

### Frontend (BaseGameClient)

- [ ] Agregar `sendGameAction()` (WebSocket en lugar de HTTP)
- [ ] Agregar `applyOptimisticUpdate()`
- [ ] Agregar `revertOptimisticUpdate()`
- [ ] Agregar `setupReconnectionHandlers()`
- [ ] Agregar `onDisconnect()`
- [ ] Agregar `onReconnecting()`
- [ ] Agregar `onReconnect()`
- [ ] Agregar `onReconnectFailed()`
- [ ] Agregar `syncState()`
- [ ] Agregar `onStateSync()`
- [ ] Agregar `processActionQueue()`
- [ ] Agregar `applyStateDelta()`
- [ ] Agregar `onDeltaApplied()`
- [ ] Agregar listeners para nuevos eventos

### Refactorizaci√≥n Trivia

- [ ] Eliminar `TriviaController::submitAnswer()` (HTTP endpoint)
- [ ] Eliminar ruta `POST /api/trivia/{code}/answer`
- [ ] Modificar `TriviaEngine::processRoundAction()` para usar `getPlayerFromState()`
- [ ] Modificar `game.blade.php` para usar `sendGameAction()` en lugar de fetch
- [ ] Probar flujo completo con 4 jugadores
- [ ] Probar disconnect/reconnect
- [ ] Benchmark latencia y queries

---

## üöÄ Estimaci√≥n de Tiempo

| Tarea | Tiempo |
|-------|--------|
| Backend: Agregar m√©todos WebSocket | 3h |
| Backend: Redis State Manager | 2h |
| Backend: Graceful disconnect/reconnect | 2h |
| Backend: Events y listeners | 1h |
| Frontend: Agregar m√©todos WebSocket | 2h |
| Frontend: Reconnection handlers | 2h |
| Frontend: State sync | 1h |
| Refactorizar Trivia | 3h |
| Testing completo | 4h |
| **TOTAL** | **~20h (2.5 d√≠as)** |

---

## üìà Mejoras Esperadas

| M√©trica | Antes | Despu√©s | Mejora |
|---------|-------|---------|--------|
| Latencia por acci√≥n | 100-200ms | 10-20ms | ~10x |
| Queries por acci√≥n | 3 | 0 | ‚àû |
| Overhead de red | ~1KB | ~10 bytes | ~100x |
| Reconexi√≥n | Manual (reload) | Autom√°tica | ‚úÖ |
| Offline actions | Perdidas | Encoladas | ‚úÖ |
| Optimistic UI | No | S√≠ | ‚úÖ |

---

## ‚úÖ Pr√≥ximos Pasos

1. Implementar mejoras en `BaseGameEngine`
2. Implementar mejoras en `BaseGameClient`
3. Crear `WebSocketActionListener`
4. Refactorizar Trivia
5. Probar con 4 jugadores
6. Documentar para nuevos juegos
