# Arquitecturas de Juegos Online - Patrones y Mejores Pr√°cticas

**Fecha:** 26 Octubre 2025
**Investigaci√≥n:** Basada en Agar.io, Among Us, Kahoot!, Socket.io + Redis, y tutoriales de Gabriel Gambetta

---

## üìã Resumen Ejecutivo

Este documento recopila los patrones y mejores pr√°cticas de arquitecturas reales de juegos multijugador online, aplicados al contexto de **GroupsGames** (plataforma para juegos presenciales con dispositivos m√≥viles).

**Conclusi√≥n Principal:** Migrar de HTTP POST a WebSocket bidireccional + Redis state puede reducir la latencia **~10x** (de 100-500ms a <50ms) y eliminar queries a BD durante el juego.

---

## üéÆ Juegos Analizados

### 1. **Agar.io** (MMO de acci√≥n r√°pida)
- **Stack:** Node.js + Socket.io + WebSocket
- **Arquitectura:** Authoritative Server
- **Estado:** Todo el game logic en servidor
- **Performance:** 1 core = 190 jugadores concurrentes
- **Network:** "Tick-tock" messaging (estado continuo)

### 2. **Among Us** (Multiplayer social)
- **Stack:** Unity + Custom UDP netcode
- **Arquitectura:** Room-based con servidor centralizado
- **Puertos:** UDP 22023-22923
- **Rooms:** M√°ximo 10-15 jugadores por partida
- **Sync:** Lightweight architecture con sincronizaci√≥n eficiente

### 3. **Kahoot!** (Quiz en tiempo real)
- **Stack:** Node.js + Socket.io + Redis + MySQL + Kafka
- **Arquitectura:** Two-view (Host + Players) sincronizados
- **Escalabilidad:** Auto-scaling para millones de usuarios
- **State:** Redis para real-time, MySQL para persistencia
- **Frontend:** React/Angular/Vue + WebSockets

---

## üèóÔ∏è Patrones Arquitect√≥nicos

### Patr√≥n #1: **Authoritative Server** (Servidor Autoritativo)

**Regla de oro:** "Don't trust the client"

```
‚ùå MAL:
Cliente dice: "Tengo 100 puntos"
Servidor: "OK, guardado"

‚úÖ BIEN:
Cliente dice: "Respond√≠ opci√≥n 2"
Servidor:
  1. Valida que no est√© bloqueado
  2. Verifica respuesta contra pregunta actual
  3. Calcula puntos si es correcta
  4. Actualiza state
  5. Broadcast resultado a todos
```

**Por qu√©:**
- Previene hacking/cheating
- Garantiza fairness
- Single source of truth
- Permite rollback/replay

**Aplicaci√≥n en GroupsGames:**
```php
// ‚ùå NUNCA hacer:
public function submitAnswer(Request $request) {
    $points = $request->input('points'); // ‚Üê Cliente dice sus puntos
    $player->score += $points;
}

// ‚úÖ SIEMPRE hacer:
public function submitAnswer(Request $request) {
    $answer = $request->input('answer_index');
    $isCorrect = $this->engine->validateAnswer($player, $answer);
    if ($isCorrect) {
        $points = $this->engine->calculatePoints($question);
        $this->engine->addScore($player, $points);
    }
}
```

---

### Patr√≥n #2: **WebSocket Bidireccional**

**HTTP POST (actual):**
```javascript
// Cliente ‚Üí Servidor
fetch('/api/trivia/ABC123/answer', {
    method: 'POST',
    body: JSON.stringify({ answer_index: 2 })
});
// Latencia: 100-500ms
// Overhead: Headers HTTP, parsing JSON, routing, etc.
```

**WebSocket (recomendado):**
```javascript
// Cliente ‚Üí Servidor
Echo.private(`room.${code}`)
    .whisper('game.action', {
        type: 'answer',
        answer_index: 2
    });
// Latencia: 10-50ms
// Overhead: M√≠nimo (conexi√≥n persistente)
```

**Comparativa:**

| M√©trica              | HTTP POST       | WebSocket      | Mejora |
|---------------------|-----------------|----------------|--------|
| Latencia            | 100-500ms       | 10-50ms        | ~10x   |
| Overhead            | ~1KB headers    | ~10 bytes      | ~100x  |
| Conexiones          | 1 por request   | 1 persistente  | ‚àû      |
| Server load         | Alto (routing)  | Bajo (directo) | ~5x    |
| Queries BD          | 2-3 por request | 0 (Redis)      | ‚àû      |

---

### Patr√≥n #3: **Redis como State Store**

**Problema con BD SQL durante el juego:**
```php
// ‚ùå Cada acci√≥n hace queries:
$room = Room::where('code', $code)
    ->with('match.players')
    ->first();
// Query 1: SELECT * FROM rooms WHERE code = ?
// Query 2: SELECT * FROM game_matches WHERE room_id = ?
// Query 3: SELECT * FROM players WHERE match_id = ?
// Tiempo: ~20-50ms POR ACCI√ìN
```

**Soluci√≥n con Redis:**
```php
// ‚úÖ Todo en memoria:
$state = Redis::get("game:match:{$matchId}:state");
$gameState = json_decode($state, true);
// Tiempo: ~1-2ms
```

**Arquitectura recomendada:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Inicio    ‚îÇ ‚Üê MySQL (persistir match, players, config)
‚îÇ   de Juego  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Durante   ‚îÇ ‚Üê Redis (game_state, player actions, scores)
‚îÇ   Juego     ‚îÇ   WebSocket (broadcast events)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Final de   ‚îÇ ‚Üê MySQL (guardar resultados, rankings, stats)
‚îÇ   Juego     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Ventajas:**
- **Speed:** Redis ~1ms vs MySQL ~20ms
- **Scalability:** Redis horizontal scaling f√°cil
- **Consistency:** Atomic operations (INCR, LPUSH, etc.)
- **Persistence:** Redis AOF/RDB para recovery

---

### Patr√≥n #4: **Room-Based Architecture**

**Concepto:**
- Cada partida = 1 Room
- Cada Room = Estado aislado
- Broadcast solo dentro del Room

**Implementaci√≥n:**

```javascript
// Cliente se une al room
Echo.join(`room.${code}`)
    .listen('.game.round.started', (data) => {
        // Solo este room recibe el evento
    });
```

```php
// Servidor broadcast solo al room
broadcast(new RoundStartedEvent($match))
    ->toOthers(); // Solo a room.{code}
```

**Ventajas:**
- Aislamiento de partidas
- Reducci√≥n de tr√°fico de red
- Escalabilidad (N rooms = N cores)
- F√°cil debugging

---

### Patr√≥n #5: **State Synchronization**

**NO enviar todo el estado en cada update:**

```javascript
// ‚ùå MAL (enviando TODO):
broadcast({
    game_state: {
        phase: 'playing',
        questions: [...100 preguntas...],
        current_question: {...},
        scores: {...},
        round_system: {...},
        timer_system: {...},
        player_states: {...}
    }
});
// Tama√±o: ~50KB por update
```

**‚úÖ BIEN (solo cambios):**

```javascript
broadcast({
    event: 'round.started',
    data: {
        current_round: 2,
        current_question: {
            id: 5,
            question: "¬øCu√°l es...?",
            options: ["A", "B", "C", "D"]
        },
        timer: 30
    }
});
// Tama√±o: ~1KB por update
```

**Delta Updates:**
```javascript
// Solo enviar lo que cambi√≥
broadcast({
    event: 'score.updated',
    player_id: 123,
    delta: +10,  // ‚Üê Solo el cambio
    new_total: 50
});
```

---

### Patr√≥n #6: **Event-Driven Architecture**

**Todo el juego funciona con eventos:**

```
Cliente                 Servidor                  Todos los clientes
   ‚îÇ                       ‚îÇ                             ‚îÇ
   ‚îÇ‚îÄ‚îÄgame.action‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  ‚îÇ                             ‚îÇ
   ‚îÇ  {answer: 2}          ‚îÇ                             ‚îÇ
   ‚îÇ                       ‚îÇ                             ‚îÇ
   ‚îÇ                       ‚îú‚îÄ Validar                    ‚îÇ
   ‚îÇ                       ‚îú‚îÄ Calcular puntos            ‚îÇ
   ‚îÇ                       ‚îú‚îÄ Actualizar state (Redis)   ‚îÇ
   ‚îÇ                       ‚îÇ                             ‚îÇ
   ‚îÇ                       ‚îú‚îÄ‚îÄgame.answer.correct‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
   ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  {player: 123, points: 10} ‚îÇ
   ‚îÇ                       ‚îÇ                             ‚îÇ
```

**Eventos t√≠picos:**

**Server ‚Üí Client (broadcast):**
- `game.initialized`
- `game.countdown`
- `game.started`
- `round.started`
- `round.ended`
- `game.ended`

**Client ‚Üí Server (actions):**
- `game.action.answer`
- `game.action.draw`
- `game.action.vote`
- `player.ready`

---

### Patr√≥n #7: **Throttling y Batching**

**Problema:** En juegos de acci√≥n r√°pida (Pictionary), el cliente puede enviar 60 events/segundo.

**Soluci√≥n 1: Client-side throttling**
```javascript
// ‚ùå Enviar cada trazo (60 fps = 60 events/s)
canvas.on('mousemove', (e) => {
    socket.emit('draw', { x: e.x, y: e.y });
});

// ‚úÖ Throttle a 10 events/s
const throttledDraw = _.throttle((point) => {
    socket.emit('draw', point);
}, 100); // Max 1 cada 100ms

canvas.on('mousemove', (e) => {
    throttledDraw({ x: e.x, y: e.y });
});
```

**Soluci√≥n 2: Server-side batching**
```javascript
const batch = [];
const BATCH_INTERVAL = 50; // 50ms

socket.on('draw', (point) => {
    batch.push(point);
});

setInterval(() => {
    if (batch.length > 0) {
        io.to(roomId).emit('draw.batch', batch);
        batch.length = 0; // Clear
    }
}, BATCH_INTERVAL);
```

---

### Patr√≥n #8: **Graceful Disconnect/Reconnect**

**Problema:** Usuario pierde WiFi moment√°neamente.

**‚ùå MAL:** Kickear inmediatamente del juego.

**‚úÖ BIEN:** Grace period + Reconnection

```javascript
// Cliente detecta desconexi√≥n
Echo.connector.socket.on('disconnect', () => {
    showReconnectingUI();
});

Echo.connector.socket.on('reconnect', () => {
    // Pedir estado actual
    fetch(`/api/rooms/${code}/state`)
        .then(state => resyncGameState(state));
    hideReconnectingUI();
});
```

```php
// Servidor
public function handlePlayerDisconnect(Player $player) {
    // No eliminar inmediatamente
    $this->setPlayerState($player->id, 'disconnected');

    // Esperar 30 segundos
    dispatch(new RemoveInactivePlayer($player))
        ->delay(now()->addSeconds(30));
}

public function handlePlayerReconnect(Player $player) {
    // Cancelar removal job
    $this->setPlayerState($player->id, 'active');

    // Enviar estado actual
    return $this->getGameStateForPlayer($player);
}
```

---

### Patr√≥n #9: **No Queries Durante el Juego**

**Principio:** El `game_state` en Redis debe contener TODO lo necesario.

```php
// ‚ùå NUNCA durante el juego:
$players = $match->players;  // Query a BD
$player = Player::find($id);  // Query a BD
$room = Room::where('code', $code)->first();  // Query a BD

// ‚úÖ SIEMPRE usar game_state:
$totalPlayers = $gameState['_config']['total_players'];
$playerName = $gameState['_config']['players'][$playerId]['name'];
$isLocked = $gameState['player_states'][$playerId]['locked'] ?? false;
```

**Estructura recomendada de game_state:**

```php
[
    '_config' => [
        'game' => 'trivia',
        'total_players' => 4,
        'players' => [
            123 => ['id' => 123, 'name' => 'Juan', 'avatar' => '...'],
            456 => ['id' => 456, 'name' => 'Maria', 'avatar' => '...'],
        ],
        'initialized_at' => '2025-10-26 10:00:00',
    ],

    'phase' => 'playing',
    'current_round' => 2,

    // M√≥dulos
    'round_system' => [...],
    'timer_system' => [...],
    'scoring_system' => [...],
    'player_states' => [...],

    // Game-specific
    'questions' => [...],
    'current_question' => [...],
]
```

---

## üìä Arquitectura Recomendada para GroupsGames

### Stack Tecnol√≥gico

```
Frontend:
‚îú‚îÄ‚îÄ Laravel Blade (SSR inicial)
‚îú‚îÄ‚îÄ Alpine.js / Vue.js (reactivity)
‚îú‚îÄ‚îÄ Laravel Echo (WebSocket client)
‚îî‚îÄ‚îÄ Pusher.js (protocol)

Backend:
‚îú‚îÄ‚îÄ Laravel 11
‚îú‚îÄ‚îÄ Laravel Reverb (WebSocket server)
‚îú‚îÄ‚îÄ Redis (state + pub/sub)
‚îî‚îÄ‚îÄ MySQL (persistencia)
```

### Flujo Completo

```
1. INICIALIZACI√ìN (MySQL)
   ‚îî‚îÄ Crear Room, Match, Players
   ‚îî‚îÄ Cargar config del juego
   ‚îî‚îÄ Initialize engine
   ‚îî‚îÄ Guardar game_state inicial

2. LOBBY (WebSocket + Redis)
   ‚îî‚îÄ Players join Presence Channel
   ‚îî‚îÄ Real-time player list
   ‚îî‚îÄ Ready checks
   ‚îî‚îÄ Countdown

3. JUEGO (WebSocket + Redis ONLY)
   ‚îî‚îÄ Cargar game_state desde Redis
   ‚îî‚îÄ Cliente env√≠a actions via WebSocket
   ‚îî‚îÄ Servidor valida y actualiza Redis
   ‚îî‚îÄ Broadcast eventos a room
   ‚îî‚îÄ Repetir hasta game over
   ‚îî‚îÄ 0 QUERIES A MYSQL

4. FINALIZACI√ìN (MySQL)
   ‚îî‚îÄ Guardar resultados finales
   ‚îî‚îÄ Calcular rankings
   ‚îî‚îÄ Actualizar stats
   ‚îî‚îÄ Liberar room
```

### Componentes Base Necesarios

**Backend:**
```
BaseGameEngine
‚îú‚îÄ‚îÄ WebSocket Action Handler
‚îú‚îÄ‚îÄ Redis State Manager
‚îú‚îÄ‚îÄ Event Broadcaster
‚îú‚îÄ‚îÄ Reconnection Handler
‚îî‚îÄ‚îÄ Module System (Round, Timer, Score, etc.)
```

**Frontend:**
```
BaseGameJS
‚îú‚îÄ‚îÄ WebSocket Manager
‚îú‚îÄ‚îÄ Event Listener System
‚îú‚îÄ‚îÄ State Synchronizer
‚îú‚îÄ‚îÄ Reconnection Handler
‚îú‚îÄ‚îÄ UI Updater
‚îî‚îÄ‚îÄ Action Sender
```

---

## üöÄ Plan de Migraci√≥n

### Fase 1: Preparar Base (2-3 d√≠as)
- [ ] Crear `BaseGameEngine` con WebSocket support
- [ ] Crear `BaseGame.js` para cliente
- [ ] Implementar Redis State Manager
- [ ] Setup bidirectional WebSocket (client ‚Üí server)

### Fase 2: Refactorizar Trivia (2 d√≠as)
- [ ] Migrar TriviaEngine a nuevo BaseEngine
- [ ] Migrar game.blade.php a BaseGame.js
- [ ] Eliminar HTTP POST endpoints
- [ ] Eliminar queries durante juego

### Fase 3: Testing (2 d√≠as)
- [ ] Test con 4 jugadores simult√°neos
- [ ] Test disconnect/reconnect
- [ ] Test race conditions
- [ ] Benchmark latencia

### Fase 4: Documentar (1 d√≠a)
- [ ] Docs para crear nuevos juegos
- [ ] API reference BaseEngine/BaseJS
- [ ] Troubleshooting guide

**Total:** 7-8 d√≠as

---

## üìà M√©tricas de √âxito

### Antes (HTTP POST + MySQL):

```
Action: Responder pregunta
‚îú‚îÄ‚îÄ HTTP POST request: ~50ms
‚îú‚îÄ‚îÄ Routing + middleware: ~10ms
‚îú‚îÄ‚îÄ Query Room: ~20ms
‚îú‚îÄ‚îÄ Query Match: ~15ms
‚îú‚îÄ‚îÄ Query Players: ~25ms
‚îú‚îÄ‚îÄ Process answer: ~5ms
‚îú‚îÄ‚îÄ Save to MySQL: ~30ms
‚îú‚îÄ‚îÄ Broadcast event: ~20ms
‚îî‚îÄ‚îÄ TOTAL: ~175ms + 3 queries
```

### Despu√©s (WebSocket + Redis):

```
Action: Responder pregunta
‚îú‚îÄ‚îÄ WebSocket message: ~5ms
‚îú‚îÄ‚îÄ Get state from Redis: ~2ms
‚îú‚îÄ‚îÄ Process answer: ~5ms
‚îú‚îÄ‚îÄ Update Redis: ~3ms
‚îú‚îÄ‚îÄ Broadcast event: ~5ms
‚îî‚îÄ‚îÄ TOTAL: ~20ms + 0 queries
```

**Mejora:** ~8.75x m√°s r√°pido, 0 queries

---

## üîí Consideraciones de Seguridad

### 1. Validaci√≥n en Servidor (SIEMPRE)
```php
// ‚ùå Confiar en el cliente
$points = $data['points'];

// ‚úÖ Calcular en servidor
$points = $this->calculatePoints($question['difficulty']);
```

### 2. Rate Limiting
```php
// Prevenir spam de acciones
RateLimiter::attempt(
    "game-action:{$playerId}",
    $perMinute = 60,
    function() use ($action) {
        $this->processAction($action);
    }
);
```

### 3. State Validation
```php
// Verificar que el jugador puede hacer esta acci√≥n
if ($gameState['phase'] !== 'playing') {
    throw new InvalidActionException();
}

if ($this->isPlayerLocked($playerId)) {
    throw new PlayerLockedException();
}
```

### 4. Replay Attack Prevention
```php
// Timestamp + nonce
$action = [
    'type' => 'answer',
    'answer_index' => 2,
    'timestamp' => now()->timestamp,
    'nonce' => Str::random(16),
];

// Servidor verifica timestamp (max 5s old)
if (now()->timestamp - $action['timestamp'] > 5) {
    throw new ExpiredActionException();
}
```

---

## üìö Referencias

**Tutoriales:**
- [Gabriel Gambetta - Client-Server Game Architecture](https://www.gabrielgambetta.com/client-server-game-architecture.html)
- [Socket.io + Redis Guide - DEV Community](https://dev.to/dowerdev/building-a-real-time-multiplayer-game-server-with-socketio-and-redis-architecture-and-583m)
- [Agar.io Clone - Game Architecture](https://github.com/huytd/agar.io-clone/wiki/Game-Architecture)

**Frameworks:**
- [Colyseus - Multiplayer Framework](https://colyseus.io/)
- [Laravel Reverb](https://reverb.laravel.com/)
- [Laravel Broadcasting](https://laravel.com/docs/12.x/broadcasting)

**Papers:**
- [Fast-Paced Multiplayer](https://www.gabrielgambetta.com/client-side-prediction-live-demo.html)
- [CRDT-Based State Sync](https://arxiv.org/html/2503.17826v1)

---

## üéØ Conclusiones

**Para GroupsGames:**

1. ‚úÖ **S√ç migrar a WebSocket bidireccional** - Latencia ~10x mejor
2. ‚úÖ **S√ç usar Redis para game state** - 0 queries durante juego
3. ‚úÖ **S√ç usar Authoritative Server** - Previene cheating
4. ‚úÖ **S√ç usar Event-Driven** - Arquitectura escalable
5. ‚ùå **NO usar Client-Side Prediction** - No necesario para juegos por turnos
6. ‚ùå **NO confiar en el cliente** - Validar TODO en servidor

**ROI Estimado:**
- Latencia: 100-500ms ‚Üí 10-50ms (~10x mejor)
- Queries: 3 por acci√≥n ‚Üí 0 (‚àû mejor)
- Escalabilidad: 50 jugadores ‚Üí 500+ jugadores (10x mejor)
- Desarrollo: 7-8 d√≠as de refactor
- Mantenimiento: M√°s simple (1 sistema en lugar de 2)

**Recomendaci√≥n:** Proceder con migraci√≥n. El esfuerzo (7-8 d√≠as) justifica las mejoras de performance y escalabilidad.
