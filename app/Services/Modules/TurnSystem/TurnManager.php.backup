<?php

namespace App\Services\Modules\TurnSystem;

use Illuminate\Support\Collection;

/**
 * Turn System Module - Gestión de turnos para juegos.
 *
 * Módulo independiente y reutilizable para gestionar el orden de turnos
 * en cualquier juego que lo necesite.
 *
 * Funcionalidades:
 * - Crear orden de turnos (aleatorio, secuencial, personalizado)
 * - Avanzar al siguiente turno (rotación circular)
 * - Detectar fin de ronda (cuando se completa un ciclo)
 * - Obtener jugador actual
 * - Soportar eliminación de jugadores
 *
 * Ejemplo de uso:
 * ```php
 * $turnManager = new TurnManager(['player1', 'player2', 'player3'], 'shuffle');
 * $currentPlayer = $turnManager->getCurrentPlayer(); // player2 (aleatorio)
 * $turnManager->nextTurn(); // Avanza al siguiente
 * $roundEnded = $turnManager->isNewRound(); // false
 * ```
 */
class TurnManager
{
    /**
     * Orden de jugadores (IDs).
     *
     * @var array
     */
    protected array $turnOrder;

    /**
     * Índice del turno actual (0-based).
     *
     * @var int
     */
    protected int $currentTurnIndex;

    /**
     * Número de ronda actual (1-based).
     *
     * @var int
     */
    protected int $currentRound;

    /**
     * Total de rondas previstas (0 = infinitas).
     *
     * @var int
     */
    protected int $totalRounds;

    /**
     * Modo de turnos: 'sequential', 'simultaneous', 'free'.
     *
     * @var string
     */
    protected string $mode;

    /**
     * Indica si en el último nextTurn() se completó una ronda.
     *
     * @var bool
     */
    protected bool $roundJustCompleted = false;

    /**
     * Indica si el sistema de turnos está pausado.
     *
     * @var bool
     */
    protected bool $isPaused = false;

    /**
     * Dirección de los turnos: 1 = forward, -1 = backward (reversed).
     *
     * @var int
     */
    protected int $direction = 1;

    /**
     * Jugadores eliminados permanentemente (fuera del juego).
     *
     * @var array<int>
     */
    protected array $permanentlyEliminated = [];

    /**
     * Jugadores eliminados temporalmente (solo este turno/ronda).
     *
     * @var array<int>
     */
    protected array $temporarilyEliminated = [];

    /**
     * Constructor.
     *
     * @param array $playerIds Array de IDs de jugadores
     * @param string $mode Modo de turnos: 'sequential', 'shuffle', 'simultaneous', 'free'
     * @param int $totalRounds Total de rondas (0 = infinitas)
     * @param int $startingRound Ronda inicial (default: 1)
     */
    public function __construct(
        array $playerIds,
        string $mode = 'sequential',
        int $totalRounds = 0,
        int $startingRound = 1
    ) {
        if (empty($playerIds)) {
            throw new \InvalidArgumentException('Se requiere al menos un jugador para el sistema de turnos');
        }

        $this->mode = $mode;
        $this->totalRounds = $totalRounds;
        $this->currentRound = $startingRound;
        $this->currentTurnIndex = 0;

        // Inicializar orden según modo
        $this->turnOrder = match ($mode) {
            'shuffle' => collect($playerIds)->shuffle()->values()->toArray(),
            'sequential' => array_values($playerIds),
            'simultaneous' => array_values($playerIds), // Todos juegan a la vez
            'free' => array_values($playerIds), // Sin orden específico
            default => array_values($playerIds),
        };
    }

    /**
     * Obtener el ID del jugador actual.
     *
     * @return mixed ID del jugador en turno
     */
    public function getCurrentPlayer(): mixed
    {
        return $this->turnOrder[$this->currentTurnIndex];
    }

    /**
     * Obtener el índice del turno actual.
     *
     * @return int Índice 0-based
     */
    public function getCurrentTurnIndex(): int
    {
        return $this->currentTurnIndex;
    }

    /**
     * Obtener la ronda actual.
     *
     * @return int Ronda actual (1-based)
     */
    public function getCurrentRound(): int
    {
        return $this->currentRound;
    }

    /**
     * Obtener el orden completo de turnos.
     *
     * @return array Array de IDs de jugadores
     */
    public function getTurnOrder(): array
    {
        return $this->turnOrder;
    }

    /**
     * Avanzar al siguiente turno.
     *
     * Rotación circular: Al llegar al último jugador, vuelve al primero
     * y aumenta el contador de ronda.
     *
     * Respeta la dirección (forward/backward) y el estado de pausa.
     *
     * @return array ['player_id' => mixed, 'turn_index' => int, 'round' => int, 'round_completed' => bool]
     */
    public function nextTurn(): array
    {
        // Si está pausado, no avanzar
        if ($this->isPaused) {
            return $this->getCurrentTurnInfo();
        }

        $this->roundJustCompleted = false;
        $playerCount = count($this->turnOrder);

        // Incrementar/decrementar índice según dirección
        $this->currentTurnIndex += $this->direction;

        // Manejar rotación circular en dirección forward
        if ($this->direction === 1) {
            if ($this->currentTurnIndex >= $playerCount) {
                $this->currentTurnIndex = 0;
                $this->currentRound++;
                $this->roundJustCompleted = true;

                // Auto-limpiar eliminaciones temporales al comenzar nueva ronda
                $this->clearTemporaryEliminations();
            }
        }
        // Manejar rotación circular en dirección backward (reversa)
        else {
            if ($this->currentTurnIndex < 0) {
                $this->currentTurnIndex = $playerCount - 1;
                $this->currentRound++;
                $this->roundJustCompleted = true;

                // Auto-limpiar eliminaciones temporales al comenzar nueva ronda
                $this->clearTemporaryEliminations();
            }
        }

        return $this->getCurrentTurnInfo();
    }

    /**
     * Verificar si se acaba de completar una ronda.
     *
     * @return bool True si en el último nextTurn() se completó una ronda
     */
    public function isNewRound(): bool
    {
        return $this->roundJustCompleted;
    }

    /**
     * Verificar si el juego ha terminado (todas las rondas completadas).
     *
     * @return bool True si se completaron todas las rondas
     */
    public function isGameComplete(): bool
    {
        if ($this->totalRounds === 0) {
            return false; // Juego infinito
        }

        return $this->currentRound > $this->totalRounds;
    }

    /**
     * Obtener información completa del turno actual.
     *
     * @return array ['player_id', 'turn_index', 'round', 'round_completed', 'game_complete']
     */
    public function getCurrentTurnInfo(): array
    {
        return [
            'player_id' => $this->getCurrentPlayer(),
            'turn_index' => $this->currentTurnIndex,
            'round' => $this->currentRound,
            'round_completed' => $this->roundJustCompleted,
            'game_complete' => $this->isGameComplete(),
        ];
    }

    /**
     * Eliminar un jugador del orden de turnos.
     *
     * IMPORTANTE: Esto ajusta el índice actual si es necesario.
     *
     * @param mixed $playerId ID del jugador a eliminar
     * @return bool True si se eliminó, false si no existía
     */
    public function removePlayer(mixed $playerId): bool
    {
        $index = array_search($playerId, $this->turnOrder, true);

        if ($index === false) {
            return false; // Jugador no existe
        }

        // Eliminar jugador
        array_splice($this->turnOrder, $index, 1);

        // Ajustar índice actual si es necesario
        if ($this->currentTurnIndex >= count($this->turnOrder)) {
            $this->currentTurnIndex = 0;
        } elseif ($index < $this->currentTurnIndex) {
            // Si eliminamos un jugador antes del actual, decrementar índice
            $this->currentTurnIndex--;
        }

        return true;
    }

    /**
     * Agregar un jugador al final del orden de turnos.
     *
     * @param mixed $playerId ID del jugador a agregar
     * @return void
     */
    public function addPlayer(mixed $playerId): void
    {
        $this->turnOrder[] = $playerId;
    }

    /**
     * Reiniciar el sistema de turnos.
     *
     * Vuelve al turno 0, ronda inicial, sin modificar el orden.
     *
     * @param int $startingRound Ronda de inicio (default: 1)
     * @return void
     */
    public function reset(int $startingRound = 1): void
    {
        $this->currentTurnIndex = 0;
        $this->currentRound = $startingRound;
        $this->roundJustCompleted = false;
    }

    /**
     * Exportar el estado actual a un array.
     *
     * Útil para guardar en game_state JSON.
     *
     * @return array Estado serializado
     */
    public function toArray(): array
    {
        return [
            'turn_order' => $this->turnOrder,
            'current_turn_index' => $this->currentTurnIndex,
            'current_round' => $this->currentRound,
            'total_rounds' => $this->totalRounds,
            'mode' => $this->mode,
            'is_paused' => $this->isPaused,
            'direction' => $this->direction,
            'permanently_eliminated' => $this->permanentlyEliminated,
            'temporarily_eliminated' => $this->temporarilyEliminated,
        ];
    }

    /**
     * Crear instancia desde un array guardado.
     *
     * @param array $state Estado previamente guardado con toArray()
     * @return self Nueva instancia restaurada
     */
    public static function fromArray(array $state): self
    {
        $instance = new self(
            $state['turn_order'],
            $state['mode'] ?? 'sequential',
            $state['total_rounds'] ?? 0,
            $state['current_round'] ?? 1
        );

        $instance->currentTurnIndex = $state['current_turn_index'] ?? 0;
        $instance->isPaused = $state['is_paused'] ?? false;
        $instance->direction = $state['direction'] ?? 1;
        $instance->permanentlyEliminated = $state['permanently_eliminated'] ?? [];
        $instance->temporarilyEliminated = $state['temporarily_eliminated'] ?? [];

        return $instance;
    }

    /**
     * Obtener el modo de turnos.
     *
     * @return string 'sequential', 'shuffle', 'simultaneous', 'free'
     */
    public function getMode(): string
    {
        return $this->mode;
    }

    /**
     * Verificar si es el turno de un jugador específico.
     *
     * @param mixed $playerId ID del jugador a verificar
     * @return bool True si es su turno
     */
    public function isPlayerTurn(mixed $playerId): bool
    {
        return $this->getCurrentPlayer() === $playerId;
    }

    /**
     * Obtener el total de jugadores activos.
     *
     * @return int Número de jugadores
     */
    public function getPlayerCount(): int
    {
        return count($this->turnOrder);
    }

    /**
     * Obtener ID del siguiente jugador sin avanzar el turno.
     *
     * @return mixed ID del siguiente jugador
     */
    public function peekNextPlayer(): mixed
    {
        $nextIndex = ($this->currentTurnIndex + $this->direction) % count($this->turnOrder);

        // Ajustar para índices negativos si vamos en reversa
        if ($nextIndex < 0) {
            $nextIndex = count($this->turnOrder) + $nextIndex;
        }

        return $this->turnOrder[$nextIndex];
    }

    /**
     * Pausar el sistema de turnos.
     *
     * Cuando está pausado, nextTurn() no avanzará el turno.
     *
     * @return void
     */
    public function pause(): void
    {
        $this->isPaused = true;
    }

    /**
     * Reanudar el sistema de turnos.
     *
     * @return void
     */
    public function resume(): void
    {
        $this->isPaused = false;
    }

    /**
     * Verificar si el sistema de turnos está pausado.
     *
     * @return bool True si está pausado
     */
    public function isPaused(): bool
    {
        return $this->isPaused;
    }

    /**
     * Invertir la dirección de los turnos.
     *
     * Si estaba en orden normal (1→2→3), pasará a (3→2→1).
     * Útil para juegos como UNO con cartas de reversa.
     *
     * @return void
     */
    public function reverse(): void
    {
        $this->direction *= -1;
    }

    /**
     * Obtener la dirección actual de los turnos.
     *
     * @return int 1 = forward, -1 = backward
     */
    public function getDirection(): int
    {
        return $this->direction;
    }

    /**
     * Verificar si los turnos van en dirección normal.
     *
     * @return bool True si va hacia adelante (forward)
     */
    public function isForward(): bool
    {
        return $this->direction === 1;
    }

    /**
     * Saltar el turno actual y avanzar al siguiente.
     *
     * Útil cuando un jugador pierde su turno por alguna condición del juego.
     *
     * @return array Información del nuevo turno (después del salto)
     */
    public function skipTurn(): array
    {
        // Simplemente avanzamos al siguiente turno
        return $this->nextTurn();
    }

    /**
     * Saltar el turno de un jugador específico una vez.
     *
     * Si es el turno de ese jugador, avanza automáticamente.
     * Si no es su turno, se marca para saltar cuando le toque.
     *
     * @param mixed $playerId ID del jugador a saltar
     * @return bool True si se saltó, false si no era su turno
     */
    public function skipPlayerTurn(mixed $playerId): bool
    {
        if ($this->isPlayerTurn($playerId)) {
            $this->skipTurn();
            return true;
        }

        return false;
    }

    // ========================================================================
    // ELIMINATION SYSTEM
    // ========================================================================

    /**
     * Eliminar un jugador del juego.
     *
     * Tipos de eliminación:
     * - permanent: true  → Jugador fuera del juego completamente (ej. Battle Royale)
     * - permanent: false → Jugador fuera solo temporalmente (ej. Pictionary: eliminado este turno)
     *
     * @param int $playerId ID del jugador a eliminar
     * @param bool $permanent Si es eliminación permanente o temporal
     * @return void
     */
    public function eliminatePlayer(int $playerId, bool $permanent = true): void
    {
        // Verificar que el jugador existe en el juego
        if (!in_array($playerId, $this->turnOrder)) {
            return; // Jugador no está en el juego
        }

        if ($permanent) {
            // Eliminación permanente
            if (!in_array($playerId, $this->permanentlyEliminated)) {
                $this->permanentlyEliminated[] = $playerId;
            }

            // Si estaba en eliminados temporales, remover (ya es permanente)
            $this->temporarilyEliminated = array_values(
                array_filter($this->temporarilyEliminated, fn($id) => $id !== $playerId)
            );
        } else {
            // Eliminación temporal
            if (!in_array($playerId, $this->temporarilyEliminated) &&
                !in_array($playerId, $this->permanentlyEliminated)) {
                $this->temporarilyEliminated[] = $playerId;
            }
        }
    }

    /**
     * Verificar si un jugador está eliminado.
     *
     * @param int $playerId ID del jugador
     * @return bool True si está eliminado (permanente o temporalmente)
     */
    public function isEliminated(int $playerId): bool
    {
        return in_array($playerId, $this->permanentlyEliminated) ||
               in_array($playerId, $this->temporarilyEliminated);
    }

    /**
     * Verificar si un jugador está eliminado permanentemente.
     *
     * @param int $playerId ID del jugador
     * @return bool True si está eliminado permanentemente
     */
    public function isPermanentlyEliminated(int $playerId): bool
    {
        return in_array($playerId, $this->permanentlyEliminated);
    }

    /**
     * Verificar si un jugador está eliminado temporalmente.
     *
     * @param int $playerId ID del jugador
     * @return bool True si está eliminado temporalmente
     */
    public function isTemporarilyEliminated(int $playerId): bool
    {
        return in_array($playerId, $this->temporarilyEliminated);
    }

    /**
     * Restaurar un jugador eliminado (solo si es eliminación temporal).
     *
     * @param int $playerId ID del jugador
     * @return bool True si se restauró, false si era eliminación permanente
     */
    public function restorePlayer(int $playerId): bool
    {
        // No se puede restaurar eliminación permanente
        if (in_array($playerId, $this->permanentlyEliminated)) {
            return false;
        }

        // Remover de eliminados temporales
        $this->temporarilyEliminated = array_values(
            array_filter($this->temporarilyEliminated, fn($id) => $id !== $playerId)
        );

        return true;
    }

    /**
     * Limpiar eliminados temporales.
     *
     * Se llama automáticamente en nextTurn() para restaurar jugadores
     * eliminados temporalmente al siguiente turno.
     *
     * @return void
     */
    public function clearTemporaryEliminations(): void
    {
        $this->temporarilyEliminated = [];
    }

    /**
     * Obtener jugadores activos (no eliminados).
     *
     * @return array<int> IDs de jugadores que AÚN pueden jugar
     */
    public function getActivePlayers(): array
    {
        return array_values(
            array_filter(
                $this->turnOrder,
                fn($playerId) => !$this->isEliminated($playerId)
            )
        );
    }

    /**
     * Obtener jugadores eliminados permanentemente.
     *
     * @return array<int> IDs de jugadores eliminados permanentemente
     */
    public function getPermanentlyEliminated(): array
    {
        return $this->permanentlyEliminated;
    }

    /**
     * Obtener jugadores eliminados temporalmente.
     *
     * @return array<int> IDs de jugadores eliminados temporalmente
     */
    public function getTemporarilyEliminated(): array
    {
        return $this->temporarilyEliminated;
    }

    /**
     * Obtener total de jugadores activos.
     *
     * @return int Cantidad de jugadores que aún pueden jugar
     */
    public function getActivePlayerCount(): int
    {
        return count($this->getActivePlayers());
    }

}
