import TimingModule from '../modules/TimingModule.js';

/**
 * BaseGameClient - Clase base para todos los juegos
 *
 * Proporciona funcionalidad com√∫n que todos los juegos necesitan:
 * - Gesti√≥n de WebSockets (EventManager)
 * - Handlers de eventos gen√©ricos (RoundStarted, RoundEnded, PlayerAction)
 * - Gesti√≥n de scores y jugadores
 * - Sistema de mensajes
 * - Sistema de timing (TimingModule)
 *
 * Cada juego extiende esta clase e implementa solo su l√≥gica espec√≠fica.
 */
export class BaseGameClient {
    constructor(config) {
        // Configuraci√≥n b√°sica
        this.roomCode = config.roomCode;
        this.playerId = config.playerId;
        this.matchId = config.matchId;
        this.gameSlug = config.gameSlug;

        // Datos del juego
        this.players = config.players || [];
        this.scores = config.scores || {};
        this.gameState = config.gameState || null;
        this.eventConfig = config.eventConfig || null;

        // Estado interno
        this.currentRound = 1;
        this.totalRounds = 10;

        // Inicializar TimingModule
        this.timing = new TimingModule();
        this.timing.configure(config.timing || {});
    }

    /**
     * Configurar EventManager y registrar handlers
     *
     * Los juegos espec√≠ficos deben llamar a este m√©todo y pueden sobrescribir handlers
     */
    setupEventManager(customHandlers = {}) {
        // Handlers por defecto que todos los juegos usan
        const defaultHandlers = {
            handleGameStarted: (event) => this.handleGameStarted(event),
            handleRoundStarted: (event) => this.handleRoundStarted(event),
            handleRoundEnded: (event) => this.handleRoundEnded(event),
            handlePlayerAction: (event) => this.handlePlayerAction(event),
        };

        // Combinar handlers por defecto con handlers custom del juego
        const handlers = { ...defaultHandlers, ...customHandlers };

        this.eventManager = new window.EventManager({
            roomCode: this.roomCode,
            gameSlug: this.gameSlug,
            eventConfig: this.eventConfig,
            handlers: handlers
        });
    }

    // ========================================================================
    // HANDLERS DE EVENTOS GEN√âRICOS
    // ========================================================================

    /**
     * Handler gen√©rico: Juego iniciado
     *
     * Este m√©todo se ejecuta cuando el juego comienza (despu√©s de que el
     * master presiona "Iniciar Juego" en el lobby).
     *
     * Se recibe el estado inicial completo del juego.
     */
    async handleGameStarted(event) {
        console.log('üéÆ [BaseGameClient] GameStartedEvent received:', event);

        // Actualizar game state con el estado inicial
        this.gameState = event.game_state;

        // Procesar timing metadata si existe
        if (event.timing) {
            console.log('‚è∞ [BaseGameClient] Processing game start timing:', event.timing);

            await this.timing.processTimingPoint(
                event.timing,
                () => this.onGameReady(),
                this.getCountdownElement()
            );
        }

        // Los juegos espec√≠ficos pueden sobrescribir este m√©todo
        // para hacer transiciones de UI, mostrar mensajes, etc.
    }

    /**
     * Handler gen√©rico: Nueva ronda iniciada
     *
     * Este m√©todo se ejecuta para TODOS los juegos cuando inicia una ronda.
     * Los juegos espec√≠ficos pueden sobrescribirlo para a√±adir l√≥gica custom.
     */
    handleRoundStarted(event) {
        // Actualizar informaci√≥n de ronda
        this.currentRound = event.current_round;
        this.totalRounds = event.total_rounds;

        // Los juegos espec√≠ficos sobrescriben este m√©todo para renderizar su contenido
    }

    /**
     * Handler gen√©rico: Ronda terminada
     *
     * Este m√©todo actualiza scores autom√°ticamente para TODOS los juegos
     * y procesa timing metadata para auto-avanzar a la siguiente ronda.
     */
    async handleRoundEnded(event) {
        // Actualizar scores (com√∫n para todos los juegos)
        if (event.scores) {
            this.scores = event.scores;
        }

        // Guardar resultados
        this.lastResults = event.results;
        this.lastRoundNumber = event.round_number;

        // Procesar timing metadata si existe
        if (event.timing) {
            console.log('‚è∞ [BaseGameClient] Processing timing metadata:', event.timing);

            await this.timing.processTimingPoint(
                event.timing,
                () => this.notifyReadyForNextRound(),
                this.getCountdownElement()
            );
        }

        // Los juegos espec√≠ficos sobrescriben este m√©todo para mostrar resultados
    }

    /**
     * Handler gen√©rico: Acci√≥n de jugador
     *
     * √ötil para mostrar indicadores de "X est√° jugando..."
     */
    handlePlayerAction(event) {
        // Los juegos pueden usar esto para mostrar feedback visual
    }

    // ========================================================================
    // M√âTODOS DE UTILIDAD COMUNES
    // ========================================================================

    /**
     * Obtener jugador por ID
     */
    getPlayer(playerId) {
        return this.players.find(p => String(p.id) === String(playerId));
    }

    /**
     * Obtener jugador actual
     */
    getCurrentPlayer() {
        return this.getPlayer(this.playerId);
    }

    /**
     * Obtener score de un jugador
     */
    getPlayerScore(playerId) {
        return this.scores[playerId] || 0;
    }

    /**
     * Mostrar mensaje en consola (los juegos pueden sobrescribir para mostrar en UI)
     */
    showMessage(message, type = 'info') {
        // Los juegos pueden sobrescribir esto para mostrar mensajes en UI
    }

    /**
     * Enviar acci√≥n al backend
     *
     * M√©todo gen√©rico para enviar cualquier acci√≥n del juego
     */
    async sendAction(endpoint, data) {
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content
                },
                body: JSON.stringify({
                    ...data,
                    room_code: this.roomCode
                })
            });

            const result = await response.json();
            return result;
        } catch (error) {
            console.error(`‚ùå [BaseGameClient] Error sending action to ${endpoint}:`, error);
            throw error;
        }
    }

    // ========================================================================
    // TIMING MODULE - Race Condition Protection
    // ========================================================================

    /**
     * Notificar al backend que el frontend est√° listo para la siguiente ronda.
     *
     * Race Condition Protection:
     * - Todos los jugadores llaman a este endpoint cuando su countdown termina
     * - El backend usa un lock mechanism para que solo el primer cliente avance
     * - Los dem√°s clientes reciben 409 Conflict y se sincronizan con RoundStartedEvent
     * - Esto previene avanzar la ronda m√∫ltiples veces
     */
    async notifyReadyForNextRound() {
        console.log('üì§ [BaseGameClient] Notifying backend: ready for next round');

        try {
            const response = await fetch(`/api/games/${this.matchId}/start-next-round`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content
                },
                body: JSON.stringify({
                    room_code: this.roomCode
                })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                console.log('‚úÖ [BaseGameClient] Successfully started next round');
            } else if (response.status === 409) {
                // 409 Conflict: Otro cliente ya est√° iniciando la ronda
                console.log('‚è∏Ô∏è  [BaseGameClient] Another client is starting the round, waiting for RoundStartedEvent...');
            } else {
                console.error('‚ùå [BaseGameClient] Error starting next round:', data.error);
            }

            // En todos los casos, el cliente se sincronizar√° con RoundStartedEvent
        } catch (error) {
            console.error('‚ùå [BaseGameClient] Network error notifying next round:', error);
        }
    }

    /**
     * Obtener elemento DOM donde mostrar countdown.
     *
     * Los juegos espec√≠ficos deben sobrescribir este m√©todo para retornar
     * el elemento donde quieren mostrar el countdown de timing.
     *
     * Ejemplo en TriviaGame:
     * getCountdownElement() {
     *     return this.questionWaiting.querySelector('p');
     * }
     *
     * @returns {HTMLElement|null} Elemento DOM o null si no hay
     */
    getCountdownElement() {
        // Por defecto, retornar null (no mostrar countdown)
        // Los juegos espec√≠ficos sobrescriben esto
        return null;
    }

    /**
     * Callback ejecutado cuando termina el countdown de inicio de juego.
     *
     * Los juegos espec√≠ficos pueden sobrescribir este m√©todo para:
     * - Cambiar el mensaje a "¬°Ha empezado la partida!"
     * - Iniciar la primera ronda
     * - Hacer transiciones de UI
     */
    onGameReady() {
        console.log('‚úÖ [BaseGameClient] Game is ready');

        // Los juegos espec√≠ficos sobrescriben esto
    }
}

// Exportar para que est√© disponible globalmente
window.BaseGameClient = BaseGameClient;
